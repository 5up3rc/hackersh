#!/usr/bin/python
#
# Copyright (C) 2013 Itzik Kotler
#
# This file is part of Hackersh.
#
# Hackersh is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# Hackersh is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Hackersh; see the file COPYING.  If not,
# see <http://www.gnu.org/licenses/>.

import sys
import argparse
import os
import pythonect
import glob
import cmd
import readline
import atexit
import textwrap
import shlex
import itertools
import logging


try:

    import _preamble

except ImportError:

    sys.exc_clear()


# Local imports

import hackersh
import hackersh.components
import hackersh.components.internal.print_
import hackersh.conio


_log = logging.getLogger('shell')


# Hackersh Console

class HackershInteractiveConsole(cmd.Cmd):

    def __init__(self, locals_):

        cmd.Cmd.__init__(self)

        self.buf = ""

        self.locals_ = locals_

        self.locals_['__IN_EVAL__'] = True

        self.histfile = locals_.get('HACKERSHHISTFILE', os.path.expanduser("~/.hackersh_history"))

        self.init_history()

        self.prompt = locals_.get('PROMPT', '> ')

        self.old_prompt = ''

        # Hack data members `self.doc_header', `self.misc_header', and `self.undoc_header' for Sections

        self.doc_header = 'Part A'
        self.misc_header = 'Part B'
        self.undoc_header = 'Part C'

    def init_history(self):

        try:

            readline.read_history_file(self.histfile)

        except IOError, e:

            _log.warn('Reading history file %s failed due to %s' % (self.histfile, e))

            # No history file

            pass

        atexit.register(self.save_history, self.histfile)

    def save_history(self, histfile):

        readline.write_history_file(histfile)

    def _groupby_cmds(self, line):

        tokens = shlex.split(line)

        groups = []

        for k, g in itertools.groupby(tokens, lambda x: x == '|' or x == '->'):

            groups.append(list(g))

        return groups

    def parseline(self, line):

        line = line.strip()

        parsed_cmd, parsed_arg, parsed_line = cmd.Cmd.parseline(self, line)

        if not parsed_cmd and parsed_line:

            groups = self._groupby_cmds(line)

            parsed_cmd = groups[-1][0]

            parsed_args = ' '.join(groups[-1][1:])

        return parsed_cmd, parsed_arg, parsed_line

    def _find_slash(self, text):

        # Starts With?

        idx = 0

        if not text.startswith('../'):

            if not text.startswith('./'):

                if not text.startswith('/'):

                    # Ends With?

                    idx = text.rfind('../')

                    if idx == -1:

                        idx = text.rfind('./')

                        if idx == -1:

                            idx = text.rfind('/')

        return idx

    def _shellcomplete(self, text, buf):

        # TODO: Need optimization (test cases: '/', '/bin/', '/bin/l', '/bin/le')

        return_value = []

        working_buffer = text

        idx = self._find_slash(text)

        if idx == -1:

            idx = self._find_slash(buf)

            if idx != -1:

                working_buffer = buf

                for i in glob.glob(working_buffer[idx:] + '*'):

                    return_value.append(i[i.rfind(text):])

        else:

            for i in glob.glob(working_buffer[idx:] + '*'):

                return_value.append(i[i.rfind('/')+1:])

        return return_value

    def completedefault(self, text, line, begidx, endidx):

        return_value = []

        if text:

            groups = self._groupby_cmds(line)

            return_value = self._shellcomplete(groups[-1][-1], line)

            if not return_value:

                return filter(lambda x: x.startswith(text), self.locals_['__COMPONENT_NAMES__'])

        else:

            # Line begins with '../' or './' or '/'

            return_value = self._shellcomplete(line, text)

            if not return_value:

                return self.locals_['__COMPONENT_NAMES__'].keys()

        return return_value

    def emptyline(self):

        return ''

    def precmd(self, line):

        new_line = line

        # Part of Multi-Line ?

        if new_line.strip().endswith('\\'):

            if not self.old_prompt:

                self.old_prompt = self.prompt

                self.prompt = '... '

            self.buf += new_line.strip()[:-1].strip()

            new_line = ''

        # End of Multi-Line?

        elif not new_line.strip().endswith('\\') and self.buf:

            # Don't .strip() to allow: "show \<ENTER><SPACE>all"

            self.buf += new_line

            new_line = self.buf

            self.prompt = self.old_prompt

            self.old_prompt = ''

            self.buf = ''

        # Replace 'EOF' to 'exit' (i.e. do_exit() for "EOF")

        if new_line == 'EOF':

            new_line = 'exit'

        if new_line == 'help ?':

            new_line = 'help help'

        return new_line

    def postcmd(self, stop, line):

        self.prompt = '... ' if self.old_prompt else self.locals_.get('PROMPT', '> ')

        return cmd.Cmd.postcmd(self, stop, line)

    def default(self, line):

        if not line.startswith('#'):

            # REPL (Read-eval-print loop)

            _log.debug('Evaluating `%s`' % line)

            try:

                return_value = hackersh.eval(line, self.locals_)

                # Empty List is not False, but Empty list is not True either

                _log.debug('Returning from hackersh.eval() with %s (Type: %s)' % (return_value, type(return_value)))

                if return_value is not False and return_value:

                    if not isinstance(return_value, list):

                        return_value = [return_value]

                    meaningful_return_value = filter(lambda x: not isinstance(x, hackersh.components.HackershError) and not isinstance(x, bool), return_value)

                    if meaningful_return_value:

                        contexts = filter(lambda x: isinstance(x, hackersh.components.Context), meaningful_return_value)

                        if len(meaningful_return_value) > 1 and contexts and contexts == meaningful_return_value:

                            hackersh.components.internal.print_.special_print_all().main([], contexts)

                        else:

                            hackersh.components.internal.print_.special_print().main([], meaningful_return_value)

                    else:

                        for error in set([n.err for n in return_value]):

                            print error

                        return_value = hackersh.components.Context()

                    if isinstance(return_value, (list, tuple)) and len(return_value) == 1:

                        return_value = return_value[0]

                    self.locals_['_'] = return_value

                    _log.debug('Return Value = %s' % self.locals_['_'])


            except SystemExit:

                raise

            except Exception as e:

                _log.exception("*** Exception:")

    def print_topics(self, header, cmds, cmdlen, maxcol):

        if header == "Part A":

            print hackersh.conio.draw_underline('Shell Builtin Commands', '=')
            print hackersh.conio.draw_tbl_from_list([['?', 'Display information about builtin commands']] + map(lambda x: [x, getattr(self, 'do_' + x).__doc__.split('\n')[0]], filter(lambda x: x != x.upper(), cmds)), ["Command", "Description"], 4)
            print ' '

    ############
    # Commands #
    ############

    def no_complete(self, text, line, begidx, endidx):

        return []

    def help_help(self):
        print 'Usage: help [<command>]'

    def do_help(self, arg):
        """Display information about builtin commands"""

        cmd.Cmd.do_help(self, arg)

    def complete_show(self, text, line, begidx, endidx):

        return filter(lambda x: x.startswith(text) or x == text, ['all', 'internal', 'external', 'root'])

    def help_show(self):
        print 'Usage: show [all|internal|external|root]'

    def do_show(self, arg):
        """Displays components"""

        if arg == 'all' or not arg:

            for opt in self.complete_show('', '', 0, 0):

                # Avoid recursion

                if opt == 'all':
                    continue

                self.do_show(opt)

        elif arg == 'root':

            print hackersh.conio.draw_underline('Root Components', '=')

            print hackersh.conio.draw_tbl_from_list(map(lambda k: [k, 'N/A' if not self.locals_[k].__doc__ else self.locals_[k].__doc__.split('.')[0]], filter(lambda x: issubclass(self.locals_[x], hackersh.components.RootComponent), self.locals_['__COMPONENT_NAMES__'])), ["Name", "Description"], 4) + '\n'

        elif arg == 'internal':

            print hackersh.conio.draw_underline('Internal Components', '=')

            print hackersh.conio.draw_tbl_from_list(map(lambda k: [k, 'N/A' if not self.locals_[k].__doc__ else self.locals_[k].__doc__.split('.')[0]], filter(lambda x: issubclass(self.locals_[x], hackersh.components.internal.InternalComponent), self.locals_['__COMPONENT_NAMES__'])), ["Name", "Description"], 4) + '\n'

        elif arg == 'external':

            print hackersh.conio.draw_underline('External Components', '=')

            print hackersh.conio.draw_tbl_from_list(map(lambda k: [k, 'N/A' if not self.locals_[k].__doc__ else self.locals_[k].__doc__.split('.')[0]], filter(lambda x: issubclass(self.locals_[x], hackersh.components.external.ExternalComponent), self.locals_['__COMPONENT_NAMES__'])), ["Name", "Description"], 4) + '\n'

        else:

            print "*** Invalid option: %s" % arg

    def complete_info(self, text, line, begidx, endidx):

        if text:

            return filter(lambda x: x.startswith(text), self.locals_['__COMPONENT_NAMES__'])

        else:

            return self.locals_['__COMPONENT_NAMES__'].keys()

    def help_info(self):

        print "Usage: info <component name>"

    def do_info(self, arg):
        """Queries the supplied component or components for information"""

        if not arg:

            return self.do_help('info')

        else:

            for component_name in arg.split():

                if component_name not in self.locals_:

                    print "*** Invalid component name: %s" % component_name

                else:

                    comp_instance = self.locals_[component_name]

                    print "Component: %s\n" \
                          "Version: %s\n" \
                          "Source: %s\n" \
                          "Type: %s\n" \
                          "Provided by: %s\n" \
                          "Filter: %s\n" \
                          "Query: %s\n" \
                          "Description:\n   %s" \
                          "\n" % ( \
                                  component_name, \
                                  sys.modules[comp_instance.__module__].__version__, \
                                  sys.modules[comp_instance.__module__].__file__, \
                                  comp_instance.__bases__[0].__name__, \
                                  sys.modules[comp_instance.__module__].__author__, \
                                  'None' if comp_instance.DEFAULT_FILTER is True else comp_instance.DEFAULT_FILTER, \
                                  comp_instance.DEFAULT_QUERY, \
                                  '\n   '.join(textwrap.wrap(comp_instance.__doc__ or '<No description>', 77)) \
                                 )

    def do_exit(self, s):
        """Exit the shell"""

        print ' '

        return True

    complete_quit = complete_exit = no_complete

    #####################
    # Command Shortcuts #
    #####################

    do_quit = do_exit


def set_or_update_env():

    os.environ['HACKERSHPATH'] = os.path.pathsep.join(os.getenv('HACKERSHPATH', '').split(os.path.pathsep) + map(lambda x: os.path.abspath(os.path.join(os.path.dirname(hackersh.components.__file__), '..', 'components')) + '/' + x, ['internal', 'external']))


def main(argv=sys.argv):

    banner = "Hackersh version %s ( http://www.hackersh.org )" % hackersh.__version__

    locals_ = {}

    locals_['_'] = hackersh.components.Context()

    # Parse command-line arguments

    parser = argparse.ArgumentParser(prog='hackersh')

    parser.add_argument('script', metavar='file', nargs='?', type=argparse.FileType('rt'))
    parser.add_argument('arg', metavar='arg', nargs='*', help='arguments passed to program in sys.argv[1:]')
    parser.add_argument('--verbose', '-v', action='count', default=0)
    parser.add_argument('--quiet', '-q', help='Do not print the normal Hackersh welcome', action='store_true', default=0)
    parser.add_argument('--version', '-V', action='version', version=banner)
    parser.add_argument('--interactive', '-i', action='store_true', default=False, help='inspect interactively after running script')
    parser.add_argument('--command', '-c', metavar='cmd', nargs='*', help='program passed in as string')

    args = parser.parse_args(args=argv[1:])

    # Set or Update Hackersh Environment Variables

    set_or_update_env()

    # Setup logging level

    if args.verbose:

        logging.getLogger('hackersh').setLevel({1: logging.WARNING, 2: logging.INFO, 3: logging.DEBUG}.get(args.verbose, logging.DEBUG))

        if args.verbose > 3:

            logging.getLogger().setLevel(logging.DEBUG)

    # Argument Passing

    if args.arg:

        sys.argv = [sys.argv[0]] + args.arg

    # Add current working directory to sys.path

    sys.path.insert(0, os.getcwd())

    # Extract components into locals_

    components = hackersh.components.get_all_components(os.getenv('HACKERSHPATH'))

    if not components:

        _log.warn('No components were found!')

    else:

        locals_.update(components)

    # Command line mode (i.e. ./hackersh -c "'127.0.0.1' | ipv4_address | nmap")

    if args.command:

        hackersh.eval(args.command[0], locals_)

    # Script-mode (i.e. ./hackersh script or #!/usr/bin/env hackersh)

    if args.script:

        content = args.script.read()

        scriptname, scriptextension = os.path.splitext(args.script.name)

        if scriptextension:

            parsers = pythonect.internal.parsers.get_parsers(os.path.abspath(os.path.join(os.path.dirname(pythonect.internal.parsers.__file__), '..', 'parsers')))

            content = parsers[scriptextension[1:]].parse(content)

            if content is None:

                raise Exception("Unable to parse %s with %s" % (scriptname, parsers[scriptextension].__repr__()))

        hackersh.eval(content, locals_)

        args.script.close()

    if not args.command and not args.script:

        args.interactive = True

    # Interactive-mode (i.e. ./pythonect)

    if args.interactive:

        motd = "Welcome to Hacker Shell Version %s!" % hackersh.__version__

        banner = "Hackersh Version %s\nCopyright (C) 2013 Itzik Kotler\nVisit http://www.hackersh.org for updates.\n" % hackersh.__version__

        HackershInteractiveConsole(locals_).cmdloop(banner + hackersh.conio.draw_msgbox(motd) if not args.quiet else '')

    return 0


# Entry Point

if __name__ == "__main__":

    sys.exit(main())
