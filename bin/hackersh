#!/usr/bin/python
#
# Copyright (C) 2013 Itzik Kotler
#
# This file is part of Hackersh.
#
# Hackersh is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# Hackersh is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Hackersh; see the file COPYING.  If not,
# see <http://www.gnu.org/licenses/>.

import sys
import argparse
import os
import pythonect
import glob
import cmd
import readline
import atexit
import textwrap
import shlex
import itertools


try:

    import _preamble

except ImportError:

    sys.exc_clear()


# Local imports

import hackersh
import hackersh.components
import hackersh.components.internal.print_
import hackersh.conio
import hackersh.log


# Hackersh Console

class HackershInteractiveConsole(cmd.Cmd):

    def __init__(self, locals_):

        cmd.Cmd.__init__(self)

        self.locals_ = locals_

        self.histfile = locals_.get('HACKERSHHISTFILE', os.path.expanduser("~/.hackersh_history"))

        self.init_history()

        self.prompt = '> '

        # Hack data members `self.doc_header', `self.misc_header', and `self.undoc_header' for Sections

        self.doc_header = 'Part A'
        self.misc_header = 'Part B'
        self.undoc_header = 'Part C'

    def init_history(self):

        try:

            readline.read_history_file(self.histfile)

        except IOError, e:

            hackersh.log.logger.warn('Reading history file %s failed due to %s' % (self.histfile, e))

            # No history file

            pass

        atexit.register(self.save_history, self.histfile)

    def save_history(self, histfile):

        readline.write_history_file(histfile)

    def _groupby_cmds(self, line):

        tokens = shlex.split(line)

        groups = []

        for k, g in itertools.groupby(tokens, lambda x: x == '|' or x == '->'):

            groups.append(list(g))

        return groups

    def parseline(self, line):

        line = line.strip()

        parsed_cmd, parsed_arg, parsed_line = cmd.Cmd.parseline(self, line)

        if not parsed_cmd:

            groups = self._groupby_cmds(line)

            parsed_cmd = groups[-1][0]

            parsed_args = ' '.join(groups[-1][1:])

        return parsed_cmd, parsed_arg, parsed_line

    def _find_slash(self, text):

        # Starts With?

        idx = 0

        if not text.startswith('../'):

            if not text.startswith('./'):

                if not text.startswith('/'):

                    # Ends With?

                    idx = text.rfind('../')

                    if idx == -1:

                        idx = text.rfind('./')

                        if idx == -1:

                            idx = text.rfind('/')

        return idx

    def _shellcomplete(self, text, buf):

        # TODO: Need optimization (test cases: '/', '/bin/', '/bin/l', '/bin/le')

        return_value = []

        working_buffer = text

        idx = self._find_slash(text)

        if idx == -1:

            idx = self._find_slash(buf)

            if idx != -1:

                working_buffer = buf

                for i in glob.glob(working_buffer[idx:] + '*'):

                    return_value.append(i[i.rfind(text):])

        else:

            for i in glob.glob(working_buffer[idx:] + '*'):

                return_value.append(i[i.rfind('/')+1:])

        return return_value

    def completedefault(self, text, line, begidx, endidx):

        return_value = []

        if text:

            groups = self._groupby_cmds(line)

            return_value = self._shellcomplete(groups[-1][-1], line)

            if not return_value:

                return filter(lambda x: x.startswith(text), self.locals_)

        else:

            # Line begins with '../' or './' or '/'

            return_value = self._shellcomplete(line, text)

            if not return_value:

                return self.locals_.keys()

        return return_value

    def precmd(self, line):

        new_line = line

        # Replace 'EOF' to 'exit' (i.e. do_exit() for "EOF")

        if new_line == 'EOF':

            new_line = 'exit'

        return new_line

    def default(self, line):

        if not line.startswith('#'):

            # REPL (Read-eval-print loop)

            hackersh.log.logger.debug('Evaluating `%s`' % line)

            return_value = hackersh.eval(line, self.locals_)

            # Empty List is not False, but Empty list is not True either

            if return_value is not False and return_value:

                # Not an empty list? Reduce!

                if isinstance(return_value, list):

                    return_value = reduce(lambda x, y: x+y if isinstance(x, hackersh.components.Context) else y+x, return_value)

                self.locals_['_'] = return_value

                self.locals_['__IN_EVAL__'] = True

                hackersh.components.internal.print_.print_().main([return_value], {})

    def print_topics(self, header, cmds, cmdlen, maxcol):

        if header == "Part A":

            print hackersh.conio.draw_underline('Shell Builtin Commands', '=')
            print hackersh.conio.draw_tbl_from_list([['?', 'Display information about builtin commands']] + map(lambda x: [x, getattr(self, 'do_' + x).__doc__.split('\n')[0]], filter(lambda x: x != x.upper(), cmds)), ["Command", "Description"], 4)
            print ' '

    ############
    # Commands #
    ############

    def no_complete(self, text, line, begidx, endidx):

        return []

    def do_help(self, arg):
        """Display information about builtin commands"""

        cmd.Cmd.do_help(self, arg)

    def do_show(self, arg):
        """Displays all components"""

        print hackersh.conio.draw_underline('Root Components', '=')

        print hackersh.conio.draw_tbl_from_list(map(lambda k: [k, 'N/A' if not self.locals_[k].__doc__ else self.locals_[k].__doc__.split('.')[0]], filter(lambda x: issubclass(self.locals_[x], hackersh.components.RootComponent), self.locals_)), ["Name", "Description"], 4) + '\n'

        print hackersh.conio.draw_underline('Internal Components', '=')

        print hackersh.conio.draw_tbl_from_list(map(lambda k: [k, 'N/A' if not self.locals_[k].__doc__ else self.locals_[k].__doc__.split('.')[0]], filter(lambda x: issubclass(self.locals_[x], hackersh.components.internal.InternalComponent), self.locals_)), ["Name", "Description"], 4) + '\n'

        print hackersh.conio.draw_underline('External Components', '=')

        print hackersh.conio.draw_tbl_from_list(map(lambda k: [k, 'N/A' if not self.locals_[k].__doc__ else self.locals_[k].__doc__.split('.')[0]], filter(lambda x: issubclass(self.locals_[x], hackersh.components.external.ExternalComponent), self.locals_)), ["Name", "Description"], 4) + '\n'

    complete_show = no_complete

    def complete_info(self, text, line, begidx, endidx):

        if text:

            return filter(lambda x: x.startswith(text), self.locals_)

        else:

            return self.locals_.keys()

    def do_info(self, arg):
        """Queries the supplied component or components for information"""

        if not arg:

            return self.do_help('info')

        else:

            for component_name in arg.split():

                if component_name not in self.locals_:

                    print "*** Invalid component name: %s" % component_name

                else:

                    comp_instance = self.locals_[component_name]

                    print "Component: %s\n" \
                          "Version: %s\n" \
                          "Source: %s\n" \
                          "Type: %s\n" \
                          "Provided by: %s\n" \
                          "Filter: %s\n" \
                          "Query: %s\n" \
                          "Description:\n   %s" \
                          "\n" % ( \
                                  component_name, \
                                  sys.modules[comp_instance.__module__].__version__, \
                                  sys.modules[comp_instance.__module__].__file__, \
                                  comp_instance.__bases__[0].__name__, \
                                  sys.modules[comp_instance.__module__].__author__, \
                                  'None' if comp_instance.DEFAULT_FILTER is True else comp_instance.DEFAULT_FILTER, \
                                  comp_instance.DEFAULT_QUERY, \
                                  '\n   '.join(textwrap.wrap(comp_instance.__doc__ or '<No description>', 77)) \
                                 )

    def do_exit(self, s):
        """Exit the shell"""

        print ' '

        return True

    complete_quit = complete_exit = no_complete

    #####################
    # Command Shortcuts #
    #####################

    do_quit = do_exit


def set_or_update_env():

    os.environ['HACKERSHPATH'] = os.path.pathsep.join(os.getenv('HACKERSHPATH', '').split(os.path.pathsep) + map(lambda x: os.path.abspath(os.path.join(os.path.dirname(hackersh.components.__file__), '..', 'components')) + '/' + x, ['internal', 'external']))


def main():

    locals_ = {}

    banner = "Hackersh version %s ( http://www.hackersh.org )" % hackersh.__version__

    # Parse command-line arguments

    parser = argparse.ArgumentParser(sys.argv)

    parser.add_argument('script', metavar='file', nargs='?', type=argparse.FileType('rt'))
    parser.add_argument('--verbose', '-v', action='count', default=0)
    parser.add_argument('--quiet', '-q', help='Do not print the normal Hackersh welcome', action='store_true', default=0)
    parser.add_argument('--version', '-V', action='version', version=banner)

    args = parser.parse_args()

    # Set or Update Hackersh Environment Variables

    set_or_update_env()

    # Setup logging level

    if args.verbose:

        hackersh.log.logger.setLevel(hackersh.log.logging.ERROR - ((args.verbose % 4) * 10))

    # Add current working directory to sys.path

    sys.path.insert(0, os.getcwd())

    # Extract components into locals_

    components = hackersh.components.get_all_components(os.getenv('HACKERSHPATH'))

    if not components:

        hackersh.log.logger.warn('No components were found!')

    else:

        locals_.update(components)

    # Script-mode (i.e. ./hackersh script or #!/usr/bin/env hackersh)

    if args.script:

        content = args.script.read()

        scriptname, scriptextension = os.path.splitext(args.script.name)

        if scriptextension:

            parsers = pythonect.internal.parsers.get_parsers(os.path.abspath(os.path.join(os.path.dirname(pythonect.internal.parsers.__file__), '..', 'parsers')))

            content = parsers[scriptextension[1:]].parse(content)

            if content is None:

                raise Exception("Unable to parse %s with %s" % (scriptname, parsers[scriptextension].__repr__()))

        hackersh.eval(content, locals_)

        args.script.close()

    # Interactive-mode (i.e. ./hackersh)

    else:

        # Change prompt

        sys.ps1 = '> '

        motd = "Welcome to Hacker Shell Version %s!" % hackersh.__version__

        banner = "Hackersh Version %s\nCopyright (C) 2013 Itzik Kotler\nVisit http://www.hackersh.org for updates.\n" % hackersh.__version__

        HackershInteractiveConsole(locals_).cmdloop(banner + hackersh.conio.draw_msgbox(motd) if not args.quiet else '')

    return 0


# Entry Point

if __name__ == "__main__":

    sys.exit(main())
